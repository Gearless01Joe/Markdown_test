# 数据清洗模块设计思路与原因

## 一、整体设计思路

### 核心设计理念

**"关注点分离 + 职责单一 + 可扩展性"**

将数据清洗任务拆分为多个层次，每个层次只负责自己的职责，通过清晰的接口进行交互。

## 二、分层架构设计

### 为什么分层？

#### 1. **配置层（settings.py）**

**设计原因**：
- ✅ **集中管理**：所有数据库配置集中在一个地方，修改方便
- ✅ **环境切换**：通过改变 `db_key` 就能切换不同环境（开发/测试/生产）
- ✅ **安全性**：配置与代码分离，便于管理敏感信息

**设计思路**：
```python
DATABASES = {
    'medicine_test': {...},  # 测试环境
    'medicine': {...},        # 生产环境
}
# 只需修改 db_key 就能切换环境
```

#### 2. **基础设施层（base_mysql.py）**

**设计原因**：
- ✅ **复用性**：所有项目都可以使用这个基础模块
- ✅ **统一管理**：数据库连接、ORM基类、CRUD基类统一管理
- ✅ **解耦**：业务代码不直接依赖SQLAlchemy，而是依赖抽象层

**设计思路**：
```python
# 统一初始化所有数据库连接
session_dict = {}
for database_key, database_item in DATABASES.items():
    # 创建连接池
    SessionLocal = sessionmaker(...)
    session_dict[database_key] = SessionLocal

# 提供通用CRUD基类
class BaseCRUD:
    def get_list_info(self, db, field, where=None):
        # 通用查询方法，所有模型都可以用
```

**好处**：
- 不需要在每个业务模块中重复写数据库连接代码
- 统一的CRUD接口，减少代码重复
- 如果更换ORM框架，只需修改这一层

#### 3. **数据访问层（NsfcTopicRcmdModels.py）**

**设计原因**：
- ✅ **业务封装**：将业务相关的数据库操作封装在一起
- ✅ **类型安全**：ORM提供类型检查和IDE自动补全
- ✅ **可维护性**：表结构变更只需修改模型定义

**设计思路**：
```python
# 定义ORM模型（表结构映射）
class NsfcTopicRcmdTaskList(Base):
    list_id = Column(Integer, primary_key=True)
    breadth_search = Column(JSON)

# 定义CRUD模型（数据库操作）
class NsfcTopicRcmdTaskListModel(BaseCRUD):
    model = NsfcTopicRcmdTaskList
    
    # 封装业务相关的数据库操作
    def fetch_records_for_cleaning(self, db, field_name, condition=None):
        # 专门为数据清洗设计的查询方法
```

**为什么把数据库操作放在模型类中？**

1. **符合ORM设计理念**：模型类不仅定义表结构，还封装相关操作
2. **业务内聚**：与表相关的所有操作都在一个类中，易于查找和维护
3. **参考现有代码风格**：团队已有代码（如 `ChatPaperPolishTaskList.py`）就是这样设计的
4. **便于扩展**：如果以后需要添加其他业务操作，直接在模型类中添加方法

**好处**：
- 业务逻辑层不需要知道SQL细节
- 数据库操作集中管理，易于维护
- 可以针对特定业务场景优化查询

#### 4. **业务逻辑层（data_cleaner.py）**

**设计原因**：
- ✅ **流程控制**：协调数据查询、处理、更新的完整流程
- ✅ **业务逻辑集中**：数据清洗的业务规则集中在一个地方
- ✅ **可测试性**：业务逻辑与数据库操作分离，便于单元测试

**设计思路**：
```python
class DataCleaner:
    def clean_breadth_search(self):
        # 步骤1：查询
        records = self._fetch_records_with_condition(...)
        # 步骤2：处理
        updates = self._process_records(..., self._process_breadth_search)
        # 步骤3：更新
        self._write_updates(...)
```

**好处**：
- 清晰的执行流程，易于理解和维护
- 可以轻松添加新的清洗任务
- 业务逻辑与数据库操作解耦

## 三、回调函数设计

### 为什么使用回调函数？

**设计原因**：
- ✅ **灵活性**：同一个处理框架可以处理不同类型的数据
- ✅ **代码复用**：`_process_records()` 方法可以处理多种数据格式
- ✅ **可扩展性**：新增数据类型只需添加新的处理函数

**设计思路**：
```python
def _process_records(self, records, field_name, processor_func):
    """processor_func 是回调函数"""
    for record in records:
        # ... 解析JSON ...
        processed_payload = processor_func(parsed_payload)  # 调用回调
        # ...
```

**使用场景**：
```python
# 处理 breadth_search 字段
updates = self._process_records(
    records, 
    'breadth_search', 
    self._process_breadth_search  # ← 回调函数1
)

# 处理 cited_articles 字段
updates = self._process_records(
    records, 
    'cited_articles', 
    self._process_cited_articles  # ← 回调函数2
)
```

**好处**：
- 避免代码重复：不需要为每种数据类型写一遍处理循环
- 易于扩展：新增数据类型只需添加新的处理函数
- 符合开闭原则：对扩展开放，对修改关闭

## 四、静态方法设计

### 为什么数据处理方法用静态方法？

**设计原因**：
- ✅ **无状态**：数据处理函数不需要访问实例变量
- ✅ **可测试性**：静态方法更容易进行单元测试
- ✅ **清晰性**：明确表示这些方法不依赖实例状态

**设计思路**：
```python
class DataCleaner:
    @staticmethod
    def _process_breadth_search(data):
        # 纯函数，只处理数据，不依赖实例状态
        return processed_data
```

**好处**：
- 可以在不实例化类的情况下测试数据处理逻辑
- 代码更清晰，表明这些方法是无状态的
- 如果将来需要，可以轻松提取为独立函数

## 五、模板方法模式

### 为什么三个清洗方法结构相同？

**设计原因**：
- ✅ **一致性**：所有清洗任务遵循相同的流程
- ✅ **可维护性**：修改流程只需修改一处
- ✅ **可读性**：代码结构清晰，易于理解

**设计思路**：
```python
def clean_breadth_search(self):
    # 步骤1：查询
    records = self._fetch_records_with_condition(...)
    # 步骤2：处理
    updates = self._process_records(..., self._process_breadth_search)
    # 步骤3：更新
    self._write_updates(...)

def clean_cited_articles_topic(self):
    # 同样的三步流程，只是参数不同
    records = self._fetch_records_with_condition(...)
    updates = self._process_records(..., self._process_cited_articles)
    self._write_updates(...)
```

**好处**：
- 代码结构统一，新人容易理解
- 如果需要修改流程（比如添加日志、错误处理），只需修改一处
- 符合DRY原则（Don't Repeat Yourself）

## 六、ORM设计

### 为什么使用ORM而不是直接写SQL？

**设计原因**：
- ✅ **类型安全**：IDE可以提供自动补全和类型检查
- ✅ **可维护性**：表结构变更只需修改模型定义
- ✅ **安全性**：ORM自动处理SQL注入问题
- ✅ **可读性**：Python代码比SQL字符串更易读

**设计思路**：
```python
# 使用ORM
model = NsfcTopicRcmdTaskListModel()
result = model.get_list_info(
    db, 
    [model.model.list_id, model.model.breadth_search],
    [model.model.breadth_search != None]
)

# 而不是直接写SQL
query = "SELECT list_id, breadth_search FROM nsfc_topic_rcmd_task_list WHERE ..."
```

**好处**：
- 代码更安全，避免SQL注入
- IDE支持更好，有自动补全
- 表结构变更影响范围小

## 七、批量更新设计

### 为什么批量更新而不是逐条更新？

**设计原因**：
- ✅ **性能**：批量更新比逐条更新快得多
- ✅ **事务控制**：可以在一个事务中完成所有更新
- ✅ **资源利用**：减少数据库连接次数

**设计思路**：
```python
def batch_update_field(self, db, field_name, updates, batch_size=100):
    # 按批次处理，每批100条
    for start in range(0, len(updates), batch_size):
        chunk = updates[start:start + batch_size]
        for record_id, processed_data in chunk:
            # 更新数据，但不立即提交
            self.update_data_info(db, ..., is_commit=False)
    # 最后统一提交
    db.commit()
```

**好处**：
- 性能提升：批量操作比逐条操作快10-100倍
- 事务一致性：要么全部成功，要么全部失败
- 可配置：可以通过 `batch_size` 调整批次大小

## 八、错误处理设计

### 为什么使用 try-except 和条件检查？

**设计原因**：
- ✅ **健壮性**：处理异常情况，避免程序崩溃
- ✅ **可调试性**：提供清晰的错误信息
- ✅ **容错性**：跳过无效数据，继续处理其他数据

**设计思路**：
```python
# 1. 模块导入容错
try:
    from base_mysql import session_dict
except ModuleNotFoundError:
    session_dict = None  # 允许在没有SQLAlchemy时运行

# 2. 数据解析容错
try:
    parsed_payload = json.loads(raw_payload)
except (json.JSONDecodeError, TypeError):
    skipped += 1  # 跳过无效数据，继续处理
    continue

# 3. 数据库操作容错
try:
    # 更新数据
    session.commit()
except Exception:
    session.rollback()  # 回滚事务
    raise
```

**好处**：
- 程序更稳定，不会因为个别数据错误而崩溃
- 可以统计处理成功和失败的数量
- 便于调试和问题定位

## 九、设计原则总结

### 1. **单一职责原则（SRP）**

每个类/函数只做一件事：
- `DataCleaner` - 只负责数据清洗流程
- `_process_records()` - 只负责处理记录
- `_standardize_project_info()` - 只负责标准化项目数据

### 2. **开闭原则（OCP）**

对扩展开放，对修改关闭：
- 新增清洗任务：只需添加新的 `clean_*()` 方法
- 新增数据类型：只需添加新的处理函数作为回调

### 3. **依赖倒置原则（DIP）**

依赖抽象而不是具体实现：
- `data_cleaner.py` 依赖 `BaseCRUD` 接口，而不是具体实现
- 通过回调函数实现策略模式

### 4. **DRY原则（Don't Repeat Yourself）**

避免代码重复：
- 三个清洗方法使用相同的模板
- 数据处理逻辑通过回调函数复用

### 5. **关注点分离（SoC）**

不同层次的关注点分离：
- 配置层：只关心配置
- 基础设施层：只关心数据库连接和通用操作
- 数据访问层：只关心业务相关的数据库操作
- 业务逻辑层：只关心业务规则和流程

## 十、设计优势总结

### 1. **可维护性**
- ✅ 代码结构清晰，易于理解
- ✅ 修改影响范围小
- ✅ 职责明确，易于定位问题

### 2. **可扩展性**
- ✅ 新增清洗任务容易
- ✅ 新增数据类型容易
- ✅ 新增数据库操作容易

### 3. **可测试性**
- ✅ 各层可以独立测试
- ✅ 静态方法易于单元测试
- ✅ 业务逻辑与数据库操作分离

### 4. **可复用性**
- ✅ `base_mysql.py` 可以被其他项目复用
- ✅ 数据处理函数可以在其他地方复用
- ✅ 模型类可以在其他业务场景复用

### 5. **性能**
- ✅ 批量操作提升性能
- ✅ 连接池管理数据库连接
- ✅ 事务控制保证数据一致性

## 十一、设计决策对比

### 为什么不直接写SQL？

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| 直接写SQL | 性能好，灵活 | 不安全，难维护 | ❌ |
| 使用ORM | 安全，易维护，类型安全 | 性能略差 | ✅ |

**选择ORM的原因**：安全性、可维护性、团队规范

### 为什么把数据库操作放在模型类中？

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| 放在业务逻辑层 | 业务逻辑集中 | 代码重复，难维护 | ❌ |
| 放在模型类中 | 业务内聚，易扩展 | 需要理解ORM | ✅ |

**选择模型类的原因**：符合ORM设计理念，参考团队现有代码风格

### 为什么使用回调函数？

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| 为每种类型写独立方法 | 简单直接 | 代码重复 | ❌ |
| 使用回调函数 | 代码复用，易扩展 | 需要理解回调 | ✅ |

**选择回调函数的原因**：代码复用，易于扩展新数据类型

## 十二、总结

### 设计核心思想

**"分层 + 抽象 + 复用"**

1. **分层**：配置 → 基础设施 → 数据访问 → 业务逻辑
2. **抽象**：通过基类和接口实现抽象
3. **复用**：通过回调函数和模板方法实现代码复用

### 设计目标

- ✅ **易维护**：代码结构清晰，职责明确
- ✅ **易扩展**：新增功能不需要修改现有代码
- ✅ **易测试**：各层可以独立测试
- ✅ **高性能**：批量操作，连接池管理
- ✅ **高可靠**：错误处理，事务控制

### 设计原则

遵循SOLID原则和设计模式，确保代码质量：
- 单一职责、开闭原则、依赖倒置
- 模板方法模式、策略模式（回调函数）
- 关注点分离、DRY原则

这样的设计使得代码既满足当前需求，又具备良好的扩展性和维护性。

